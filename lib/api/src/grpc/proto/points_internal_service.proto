syntax = "proto3";

import "points.proto";

package solvio;
option csharp_namespace = "Solvio.Client.Grpc";

service PointsInternal {
  rpc Upsert (UpsertPointsInternal) returns (PointsOperationResponseInternal) {}
  rpc Sync (SyncPointsInternal) returns (PointsOperationResponseInternal) {}
  rpc Delete (DeletePointsInternal) returns (PointsOperationResponseInternal) {}
  rpc UpdateVectors (UpdateVectorsInternal) returns (PointsOperationResponseInternal) {}
  rpc DeleteVectors (DeleteVectorsInternal) returns (PointsOperationResponseInternal) {}
  rpc SetPayload (SetPayloadPointsInternal) returns (PointsOperationResponseInternal) {}
  rpc OverwritePayload (SetPayloadPointsInternal) returns (PointsOperationResponseInternal) {}
  rpc DeletePayload (DeletePayloadPointsInternal) returns (PointsOperationResponseInternal) {}
  rpc ClearPayload (ClearPayloadPointsInternal) returns (PointsOperationResponseInternal) {}
  rpc CreateFieldIndex (CreateFieldIndexCollectionInternal) returns (PointsOperationResponseInternal) {}
  rpc DeleteFieldIndex (DeleteFieldIndexCollectionInternal) returns (PointsOperationResponseInternal) {}
  rpc Search (SearchPointsInternal) returns (SearchResponse) {}
  rpc SearchBatch (SearchBatchPointsInternal) returns (SearchBatchResponse) {}
  rpc CoreSearchBatch (CoreSearchBatchPointsInternal) returns (SearchBatchResponse) {}
  rpc Scroll (ScrollPointsInternal) returns (ScrollResponse) {}
  rpc Count (CountPointsInternal) returns (CountResponse) {}
  rpc Recommend (RecommendPointsInternal) returns (RecommendResponse) {}
  rpc Get (GetPointsInternal) returns (GetResponse) {}
  rpc Query (QueryPointsInternal) returns (QueryResponse) {}
}


message SyncPoints {
  string collection_name = 1; // name of the collection
  optional bool wait = 2; // Wait until the changes have been applied?
  repeated PointStruct points = 3;
  optional PointId from_id = 4; // Start of the sync range
  optional PointId to_id = 5; // End of the sync range
  optional WriteOrdering ordering = 6;
}

message SyncPointsInternal {
  SyncPoints sync_points = 1;
  optional uint32 shard_id = 2;
  optional ClockTag clock_tag = 3;
}

message UpsertPointsInternal {
  UpsertPoints upsert_points = 1;
  optional uint32 shard_id = 2;
  optional ClockTag clock_tag = 3;
}

message DeletePointsInternal {
  DeletePoints delete_points = 1;
  optional uint32 shard_id = 2;
  optional ClockTag clock_tag = 3;
}

message UpdateVectorsInternal {
  UpdatePointVectors update_vectors = 1;
  optional uint32 shard_id = 2;
  optional ClockTag clock_tag = 3;
}

message DeleteVectorsInternal {
  DeletePointVectors delete_vectors = 1;
  optional uint32 shard_id = 2;
  optional ClockTag clock_tag = 3;
}

message SetPayloadPointsInternal {
  SetPayloadPoints set_payload_points = 1;
  optional uint32 shard_id = 2;
  optional ClockTag clock_tag = 3;
}

message DeletePayloadPointsInternal {
  DeletePayloadPoints delete_payload_points = 1;
  optional uint32 shard_id = 2;
  optional ClockTag clock_tag = 3;
}

message ClearPayloadPointsInternal {
  ClearPayloadPoints clear_payload_points = 1;
  optional uint32 shard_id = 2;
  optional ClockTag clock_tag = 3;
}

message CreateFieldIndexCollectionInternal {
  CreateFieldIndexCollection create_field_index_collection = 1;
  optional uint32 shard_id = 2;
  optional ClockTag clock_tag = 3;
}

message DeleteFieldIndexCollectionInternal {
  DeleteFieldIndexCollection delete_field_index_collection = 1;
  optional uint32 shard_id = 2;
  optional ClockTag clock_tag = 3;
}

// Has to be backward compatible with `PointsOperationResponse`!
message PointsOperationResponseInternal {
  UpdateResultInternal result = 1;
  double time = 2; // Time spent to process
}

// Has to be backward compatible with `UpdateResult`!
message UpdateResultInternal {
  optional uint64 operation_id = 1; // Number of operation
  UpdateStatus status = 2; // Operation status
  optional ClockTag clock_tag = 3;
}

message ClockTag {
  uint64 peer_id = 1;
  uint32 clock_id = 2;
  uint64 clock_tick = 3;
  uint64 token = 4;
  bool force = 5;
}

message SearchPointsInternal {
  SearchPoints search_points = 1;
  optional uint32 shard_id = 2;
}

message SearchBatchPointsInternal {
  string collection_name = 1;
  repeated SearchPoints search_points = 2;
  optional uint32 shard_id = 3;
  optional uint64 timeout = 4;
}

message RecoQuery {
  repeated Vector positives = 1;
  repeated Vector negatives = 2;
}

message ContextPair {
  Vector positive = 1;
  Vector negative = 2;
}

message DiscoveryQuery {
  Vector target = 1;
  repeated ContextPair context = 2;
}

message ContextQuery {
  repeated ContextPair context = 1;
}

message QueryEnum {
  oneof query {
    Vector nearest_neighbors = 1; // ANN
    RecoQuery recommend_best_score = 2; // Recommend points with higher similarity to positive examples
    DiscoveryQuery discover = 3; // Search for points that get closer to a target, constrained by a context of positive and negative pairs
    ContextQuery context = 4; // Use only the context to find points that minimize loss against negative examples
  }
}

// This is only used internally, so it makes more sense to add it here rather than in points.proto
message CoreSearchPoints {
  string collection_name = 1;
  QueryEnum query = 2;
  Filter filter = 3;
  uint64 limit = 4;
  WithPayloadSelector with_payload = 5;
  SearchParams params = 6;
  optional float score_threshold = 7;
  optional uint64 offset = 8;
  optional string vector_name = 9;
  optional WithVectorsSelector with_vectors = 10;
  optional ReadConsistency read_consistency = 11;
}

message CoreSearchBatchPointsInternal {
  string collection_name = 1;
  repeated CoreSearchPoints search_points = 2;
  optional uint32 shard_id = 3;
  optional uint64 timeout = 4;
}

message ScrollPointsInternal {
  ScrollPoints scroll_points = 1;
  optional uint32 shard_id = 2;
}

message RecommendPointsInternal {
  RecommendPoints recommend_points = 1;
  optional uint32 shard_id = 2;
}

message GetPointsInternal {
  GetPoints get_points = 1;
  optional uint32 shard_id = 2;
}

message CountPointsInternal {
  CountPoints count_points = 1;
  optional uint32 shard_id = 2;
}

message PlannedQueryPoints {
  message VectorRescore { 
    QueryEnum query = 1;
    string using = 2;
  }

  message Rescore {
    oneof rescore {
      VectorRescore vector = 1;
    }
  }

  message Merge {
    optional Rescore rescore = 1;
    uint64 limit = 2;
  }

  message Source {
    oneof source {
      uint64 batch_idx = 1;
      Prefetch prefetch = 2;
    }
  }

  message Prefetch {
    repeated Source sources = 1;
    Merge merge = 2;
  }

  repeated CoreSearchPoints core_searches = 1;
  Prefetch merge_plan = 2;
  uint64 limit = 3;
  uint64 offset = 4;
  WithPayloadSelector with_payload = 5;
  WithVectorsSelector with_vectors = 6;
}

message QueryPointsInternal {
  PlannedQueryPoints planned_query_points = 1;
  optional uint32 shard_id = 2;
}

message QueryResponse {
  repeated ScoredPoint result = 1;
  double time = 2; // Time spent to process
}
