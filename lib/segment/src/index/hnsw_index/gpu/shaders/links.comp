#ifndef LINKS_HEADER
#define LINKS_HEADER

#ifndef LINKS_LAYOUT_SET
#error "LINKS_LAYOUT_SET not defined"
#endif

#include "common.comp"

layout(set = LINKS_LAYOUT_SET, binding = 0)
readonly uniform LinksParams {
    uint m;
} links_params;

layout(set = LINKS_LAYOUT_SET, binding = 1)
buffer Links {
    POINT_ID data[];
} links;

#define LEVEL_M links_params.m

#define LINKS_CONTAINER_OFFSET(ID) \
    ID * (LINKS_CAPACITY + 1)

#define LINKS_COUNT(ID) \
    links.data[LINKS_CONTAINER_OFFSET(ID)]

#define GET_LINK(ID, I) \
    links.data[LINKS_CONTAINER_OFFSET(ID) + 1 + I]

#define LINKS_SET_SIZE(ID, SIZE) \
    links.data[LINKS_CONTAINER_OFFSET(ID)] = SIZE

uint get_links_count(POINT_ID id) {
    uint links_count;
    if (gl_LocalInvocationID.x == 0) {
        links_count = LINKS_COUNT(id);
    }

#if WORKGROUP_SIZE > SUBGROUP_SIZE
    if (gl_LocalInvocationID.x == 0) {
        sync_uint = links_count;
    }
    memoryBarrierShared();
    barrier();
    if (gl_SubgroupInvocationID == 0 && gl_LocalInvocationID.x != 0) {
        links_count = sync_uint;
    }
#endif

    return subgroupBroadcast(links_count, 0);
}

uint cached_link;

uint iterate_link(POINT_ID id, uint i, uint links_count) {
    uint cached_i = i % WORKGROUP_SIZE;
    if (cached_i == 0 && i + gl_LocalInvocationID.x < links_count) {
        cached_link = GET_LINK(id, i + gl_LocalInvocationID.x);
    }

#if WORKGROUP_SIZE > SUBGROUP_SIZE
    if (cached_i == gl_LocalInvocationID.x) {
        sync_uint = cached_link;
    }
    memoryBarrierShared();
    barrier();
    uint link;
    if (gl_SubgroupInvocationID == 0) {
        link = sync_uint;
    }
    return subgroupBroadcast(link, 0);
#else
    return subgroupShuffle(cached_link, cached_i);
#endif
}

#endif
