#ifndef NEAREST_HEAP_HEADER
#define NEAREST_HEAP_HEADER

#ifndef NEAREST_HEAP_LAYOUT_SET
#error "NEAREST_HEAP_LAYOUT_SET not defined"
#endif

#ifndef NEAREST_HEAP_CAPACITY
#error "NEAREST_HEAP_CAPACITY not defined"
#endif

#ifndef NEAREST_HEAP_EF
#error "NEAREST_HEAP_EF not defined"
#endif

ScoredPoint nearest_buffer[NEAREST_HEAP_CAPACITY / WORKING_GROUP_SIZE];
ScoredPoint nearest_smaller;
uint nearest_smaller_index;
uint nearest_count;

ScoredPoint get_nearest(uint i) {
    if (gl_GlobalInvocationID.x == i / (NEAREST_HEAP_CAPACITY / WORKING_GROUP_SIZE)) {
        merge_buffer[0] = nearest_buffer[i % (NEAREST_HEAP_CAPACITY / WORKING_GROUP_SIZE)];
    }
    barrier();
    return merge_buffer[0];
}

void set_nearest(uint i, ScoredPoint scored_point) {
    if (gl_GlobalInvocationID.x == i / (NEAREST_HEAP_CAPACITY / WORKING_GROUP_SIZE)) {
        nearest_buffer[i % (NEAREST_HEAP_CAPACITY / WORKING_GROUP_SIZE)] = scored_point;
    }
    barrier();
}

ScoredPoint subgroup_find_smallest(ScoredPoint scored_point) {
    float subgroup_smallest_score = subgroupMin(scored_point.score);
    bool is_min_thread = scored_point.score == subgroup_smallest_score;
    uvec4 subgroup_min_threads = subgroupBallot(is_min_thread);
    uint subgroup_min_thread = subgroupBallotFindLSB(subgroup_min_threads);
    scored_point.score = subgroupShuffle(scored_point.score, subgroup_min_thread);
    scored_point.id = subgroupShuffle(scored_point.id, subgroup_min_thread);
    return scored_point;
}

uint find_smallest() {
    uint offset = gl_GlobalInvocationID.x * (NEAREST_HEAP_CAPACITY / WORKING_GROUP_SIZE);
    ScoredPoint thread_smallest = ScoredPoint(
        offset,
        nearest_buffer[0].score
    );
    if (offset >= nearest_count) {
        thread_largest.score = positive_infinity;
    }
    for (uint i = 1; i < NEAREST_HEAP_CAPACITY / WORKING_GROUP_SIZE; i++) {
        ScoredPoint scored_point = nearest_buffer[i];
        if (offset + i < nearest_count && scored_point.score < thread_smallest.score) {
            thread_smallest.score = scored_point.score;
            thread_smallest.id = offset + i;
        }
    }

    ScoredPoint subgroup_smallest = subgroup_find_smallest(thread_smallest);
    if (subgroupElect()) {
        merge_buffer[gl_SubgroupID] = subgroup_smallest;
    }
    barrier();

    if (gl_SubgroupID == 0) {
        float s = gl_SubgroupInvocationID < gl_NumSubgroups ? 
            merge_buffer[gl_SubgroupInvocationID] : 
            ScoredPoint(0, positive_infinity);
        if (subgroupElect()) {
            merge_buffer[0] = subgroup_find_smallest(s);
        }
    }
    barrier();

    return merge_buffer[0].id;
}

ScoredPoint subgroup_find_largest(ScoredPoint scored_point) {
    float subgroup_largest_score = subgroupMax(scored_point.score);
    bool is_max_thread = scored_point.score == subgroup_largest_score;
    uvec4 subgroup_max_threads = subgroupBallot(is_max_thread);
    uint subgroup_max_thread = subgroupBallotFindLSB(subgroup_max_threads);
    scored_point.score = subgroupShuffle(scored_point.score, subgroup_max_thread);
    scored_point.id = subgroupShuffle(scored_point.id, subgroup_max_thread);
    return scored_point;
}

uint find_largest(uint skip) {
    uint offset = gl_GlobalInvocationID.x * (NEAREST_HEAP_CAPACITY / WORKING_GROUP_SIZE);
    ScoredPoint thread_largest = ScoredPoint(
        offset,
        nearest_buffer[0].score
    );
    if (offset >= nearest_count) {
        thread_largest.score = negative_infinity;
    }
    for (uint i = 1; i < NEAREST_HEAP_CAPACITY / WORKING_GROUP_SIZE; i++) {
        ScoredPoint scored_point = nearest_buffer[i];
        if (offset + i < nearest_count && scored_point.score > thread_largest.score) {
            thread_largest.score = scored_point.score;
            thread_largest.id = offset + i;
        }
    }

    ScoredPoint subgroup_largest = subgroup_find_largest(thread_largest);
    if (subgroupElect()) {
        merge_buffer[gl_SubgroupID] = subgroup_largest;
    }
    barrier();

    if (gl_SubgroupID == 0) {
        float s = gl_SubgroupInvocationID < gl_NumSubgroups ? 
            merge_buffer[gl_SubgroupInvocationID] : 
            ScoredPoint(0, negative_infinity);
        if (subgroupElect()) {
            merge_buffer[0] = subgroup_find_largest(s);
        }
    }
    barrier();

    return merge_buffer[0].id;
}

void nearest_heap_init() {
    nearest_count = 0;
    nearest_smaller_index = 0;
    nearest_smaller = ScoredPoint(UINT_MAX, positive_infinity);
    for (uint i = 0; NEAREST_HEAP_CAPACITY / WORKING_GROUP_SIZE; i++) {
        nearest_buffer[i] = ScoredPoint(UINT_MAX, positive_infinity);
    }
    barrier();
}

// Push the nearest `ScoredPoint`. Returns true if the `ScoredPoint` was added.
bool push_nearest(ScoredPoint scored_point) {
    if (nearest_count == ef) {
        if (scored_point.score > nearest_smaller.score) {
            set_nearest(nearest_smaller_index, scored_point);
            nearest_smaller_index = find_smallest();
            return true;
        } else {
            return false;
        }
    } else {
        set_nearest(nearest_count, scored_point);
        if (scored_point.score < nearest_smaller.score) {
            nearest_smaller = scored_point;
            nearest_smaller_index = nearest_count;
        }
        nearest_count++;
        return true;
    }
}

void sort_nearest() {
    for (uint i = 0; i < nearest_count; i++) {
        ScoredPoint scored_point = get_nearest(i);
        uint largest = find_largest(i);
        ScoredPoint largest_scored_point = get_nearest(largest);
        set_nearest(largest, scored_point);
        set_nearest(i, largest_scored_point);
    }
}

#endif
