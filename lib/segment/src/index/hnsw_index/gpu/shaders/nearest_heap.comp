#ifndef NEAREST_HEAP_HEADER
#define NEAREST_HEAP_HEADER

#ifndef NEAREST_HEAP_CAPACITY
#error "NEAREST_HEAP_CAPACITY not defined"
#endif

#ifndef NEAREST_HEAP_EF
#error "NEAREST_HEAP_EF not defined"
#endif

shared ScoredPoint nearest_buffer[NEAREST_HEAP_CAPACITY];
ScoredPoint nearest_smaller;
uint nearest_smaller_index;
uint nearest_count;

ScoredPoint get_nearest(uint i) {
    return nearest_buffer[i];
}

void set_nearest(uint i, ScoredPoint scored_point) {
    if (gl_GlobalInvocationID.x == 0) {
        nearest_buffer[i] = scored_point;
    }
    barrier();
}

ScoredPoint subgroup_find_smallest(ScoredPoint scored_point) {
    float subgroup_smallest_score = subgroupMin(scored_point.score);
    bool is_min_thread = scored_point.score == subgroup_smallest_score;
    uvec4 subgroup_min_threads = subgroupBallot(is_min_thread);
    uint subgroup_min_thread = subgroupBallotFindLSB(subgroup_min_threads);
    return ScoredPoint(
        subgroupShuffle(scored_point.id, subgroup_min_thread),
        subgroupShuffle(scored_point.score, subgroup_min_thread)
    );
}

ScoredPoint subgroup_find_largest(ScoredPoint scored_point) {
    float subgroup_largest_score = subgroupMax(scored_point.score);
    bool is_max_thread = scored_point.score == subgroup_largest_score;
    uvec4 subgroup_max_threads = subgroupBallot(is_max_thread);
    uint subgroup_max_thread = subgroupBallotFindLSB(subgroup_max_threads);
    return ScoredPoint(
        subgroupShuffle(scored_point.id, subgroup_max_thread),
        subgroupShuffle(scored_point.score, subgroup_max_thread)
    );
}

uint find_smallest() {
    ScoredPoint thread_smallest = ScoredPoint(0, positive_infinity);
    for (uint i = gl_GlobalInvocationID.x; i < nearest_count; i += WORKING_GROUP_SIZE) {
        ScoredPoint scored_point = nearest_buffer[i];
        if (scored_point.score < thread_smallest.score) {
            thread_smallest.score = scored_point.score;
            thread_smallest.id = i;
        }
    }

    ScoredPoint subgroup_smallest = subgroup_find_smallest(thread_smallest);
    if (subgroupElect()) {
        merge_buffer[gl_SubgroupID] = subgroup_smallest;
    }
    barrier();

    if (gl_SubgroupID == 0) {
        ScoredPoint s = gl_SubgroupInvocationID < gl_NumSubgroups ? 
            merge_buffer[gl_SubgroupInvocationID] : 
            ScoredPoint(0, positive_infinity);
        ScoredPoint group_result = subgroup_find_smallest(s);
        if (subgroupElect()) {
            merge_buffer[0] = group_result;
        }
    }
    barrier();

    return merge_buffer[0].id;
}

uint find_largest(uint skip) {
    ScoredPoint thread_largest = ScoredPoint(0, negative_infinity);
    for (uint i = gl_GlobalInvocationID.x; i < nearest_count; i += WORKING_GROUP_SIZE) {
        ScoredPoint scored_point = nearest_buffer[i];
        if (i >= skip && scored_point.score > thread_largest.score) {
            thread_largest.score = scored_point.score;
            thread_largest.id = i;
        }
    }

    ScoredPoint subgroup_largest = subgroup_find_largest(thread_largest);
    if (subgroupElect()) {
        merge_buffer[gl_SubgroupID] = subgroup_largest;
    }
    barrier();

    if (gl_SubgroupID == 0) {
        ScoredPoint s = gl_SubgroupInvocationID < gl_NumSubgroups ? 
            merge_buffer[gl_SubgroupInvocationID] : 
            ScoredPoint(0, negative_infinity);
        ScoredPoint group_result = subgroup_find_largest(s);
        if (subgroupElect()) {
            merge_buffer[0] = group_result;
        }
    }
    barrier();

    return merge_buffer[0].id;
}

void nearest_heap_init() {
    nearest_count = 0;
    nearest_smaller_index = 0;
    nearest_smaller = ScoredPoint(UINT_MAX, positive_infinity);
    for (uint i = gl_GlobalInvocationID.x; i < NEAREST_HEAP_CAPACITY; i += WORKING_GROUP_SIZE) {
        nearest_buffer[i] = ScoredPoint(UINT_MAX, positive_infinity);
    }
    barrier();
}

// Push the nearest `ScoredPoint`. Returns true if the `ScoredPoint` was added.
bool push_nearest(ScoredPoint scored_point) {
    if (nearest_count == NEAREST_HEAP_EF) {
        if (scored_point.score > nearest_smaller.score) {
            set_nearest(nearest_smaller_index, scored_point);
            nearest_smaller_index = find_smallest();
            nearest_smaller = get_nearest(nearest_smaller_index);
            return true;
        } else {
            return false;
        }
    } else {
        set_nearest(nearest_count, scored_point);
        if (scored_point.score < nearest_smaller.score) {
            nearest_smaller = scored_point;
            nearest_smaller_index = nearest_count;
        }
        nearest_count++;
        return true;
    }
}

void sort_nearest() {
    for (uint i = 0; i < nearest_count; i++) {
        ScoredPoint scored_point = get_nearest(i);
        uint largest = find_largest(i);
        ScoredPoint largest_scored_point = get_nearest(largest);
        set_nearest(largest, scored_point);
        set_nearest(i, largest_scored_point);
    }
}

#endif
