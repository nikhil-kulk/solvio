#ifndef NEAREST_HEAP_HEADER
#define NEAREST_HEAP_HEADER

#ifndef NEAREST_HEAP_LAYOUT_SET
#error "NEAREST_HEAP_LAYOUT_SET not defined"
#endif

#include "common.comp"

layout(set = NEAREST_HEAP_LAYOUT_SET, binding = 0)
readonly uniform NearestHeapParams {
    uint capacity;
    uint ef;
} nearest_heap_params;

layout(set = NEAREST_HEAP_LAYOUT_SET, binding = 1)
buffer NearestScores {
    ScoredPoint data[];
} nearest_data;

float nearest_smaller_score;
uint nearest_smaller_index;
uint nearest_count;

#define NEAREST_HEAP_CAPACITY nearest_heap_params.capacity
#define NEAREST_HEAP_EF nearest_heap_params.ef
#define NEAREST_BUFFER_OFFSET (NEAREST_HEAP_CAPACITY * (gl_GlobalInvocationID.x / SUBGROUP_SIZE))

void nearest_heap_init() {
    nearest_count = 0;
    nearest_smaller_index = 0;
    nearest_smaller_score = positive_infinity;

    uint buffer_offset = NEAREST_BUFFER_OFFSET;
    uint capacity = NEAREST_HEAP_CAPACITY;
    for (uint i = SUBGROUP_INVOKATION_ID; i < capacity; i += SUBGROUP_SIZE) {
        uint buffer_index = buffer_offset + i;
        nearest_data.data[buffer_index] = ScoredPoint(0, negative_infinity);
    }
    groupMemoryBarrier();
}

// Push the nearest `ScoredPoint`. Returns true if the `ScoredPoint` was added.
bool push_nearest(ScoredPoint scored_point) {
    uint ef = NEAREST_HEAP_EF;
    if (nearest_count == ef) {
        if (scored_point.score > nearest_smaller_score) {
            uint buffer_offset = NEAREST_BUFFER_OFFSET;
            if (subgroupElect()) {
                uint buffer_index = buffer_offset + nearest_smaller_index;
                nearest_data.data[buffer_index] = scored_point;
            }
            groupMemoryBarrier(); // TODO: is this necessary? We can write and read in the same shader invocation

            nearest_smaller_index = 0;
            nearest_smaller_score = positive_infinity;
            for (uint i = SUBGROUP_INVOKATION_ID; i < ef; i += SUBGROUP_SIZE) {
                uint buffer_index = buffer_offset + i;
                float score = nearest_data.data[buffer_index].score;
                if (score < nearest_smaller_score) {
                    nearest_smaller_score = score;
                    nearest_smaller_index = i;
                }
            }

            float subgroup_smaller = subgroupMin(nearest_smaller_score);
            bool is_min_thread = nearest_smaller_score == subgroup_smaller;
            uvec4 subgroup_min_threads = subgroupBallot(is_min_thread);
            uint subgroup_min_thread = subgroupBallotFindLSB(subgroup_min_threads);
            nearest_smaller_index = subgroupShuffle(nearest_smaller_index, subgroup_min_thread);
            nearest_smaller_score = subgroupShuffle(nearest_smaller_score, subgroup_min_thread);

            return true;
        } else {
            return false;
        }
    } else {
        if (subgroupElect()) {
            uint buffer_index = NEAREST_BUFFER_OFFSET + nearest_count;
            nearest_data.data[buffer_index] = scored_point;
        }
        groupMemoryBarrier(); // TODO: is this necessary? We can write and read in the same shader invocation

        if (scored_point.score < nearest_smaller_score) {
            nearest_smaller_score = scored_point.score;
            nearest_smaller_index = nearest_count;
        }
        nearest_count++;
        return true;
    }
}

uint subgroup_bubble_sort(float score) {
    uint invocation = SUBGROUP_INVOKATION_ID;
    bool is_even = invocation % 2 == 0;
    uint invocation_forward = is_even ? invocation + 1 : invocation - 1;
    uint invocation_backward = invocation;
    if (invocation != SUBGROUP_SIZE - 1 && invocation != 0) {
        invocation_backward = is_even ? invocation - 1 : invocation + 1;
    }

    uint index = invocation;
    for (uint j = 0; j < SUBGROUP_SIZE / 2; j++) {
        bool is_even = SUBGROUP_INVOKATION_ID % 2 == 0;
        bool was_changed = false;

        // step one: compare with the next element
        {
            float next_score = subgroupShuffle(score, invocation_forward);
            uint next_index = subgroupShuffle(index, invocation_forward);
            bool need_exchange = is_even ? score < next_score : score > next_score;
            if (need_exchange) {
                was_changed = true;
                score = next_score;
                index = next_index;
            }
        }

        // step two: compare with previous element
        {
            float next_score = subgroupShuffle(score, invocation_backward);
            uint next_index = subgroupShuffle(index, invocation_backward);
            bool need_exchange = is_even ? score > next_score : score < next_score;
            if (need_exchange) {
                was_changed = true;
                score = next_score;
                index = next_index;
            }
        }

        if (!subgroupAny(was_changed)) {
            break;
        }
    }
    return index;
}

void sort_nearest() {
    uint buffer_offset = NEAREST_BUFFER_OFFSET;

    uint iterations_count = nearest_count / (SUBGROUP_SIZE / 2) + uint(sign(float(nearest_count % (SUBGROUP_SIZE / 2))));
    for (uint _cnt = 0; _cnt < iterations_count; _cnt++) {
        // do bubble sort in each subgroup to reduce the number of memory accesses
        for (uint i = SUBGROUP_INVOKATION_ID; i < NEAREST_HEAP_CAPACITY; i += SUBGROUP_SIZE) {
            ScoredPoint scores_point = nearest_data.data[buffer_offset + i];
            uint permut = subgroup_bubble_sort(scores_point.score);
            float shuffled_scores_point_score = subgroupShuffle(scores_point.score, permut);
            uint shuffled_scores_point_id = subgroupShuffle(scores_point.id, permut);
            nearest_data.data[buffer_offset + i] = ScoredPoint(shuffled_scores_point_id, shuffled_scores_point_score);
            groupMemoryBarrier();
        }

        if (NEAREST_HEAP_CAPACITY > SUBGROUP_SIZE) {
            // do bubble sort in each subgroup to reduce the number of memory accesses
            for (uint i = SUBGROUP_INVOKATION_ID + (SUBGROUP_SIZE / 2); i < NEAREST_HEAP_CAPACITY - (SUBGROUP_SIZE / 2); i += SUBGROUP_SIZE) {
                ScoredPoint scores_point = nearest_data.data[buffer_offset + i];
                uint permut = subgroup_bubble_sort(scores_point.score);
                float shuffled_scores_point_score = subgroupShuffle(scores_point.score, permut);
                uint shuffled_scores_point_id = subgroupShuffle(scores_point.id, permut);
                nearest_data.data[buffer_offset + i] = ScoredPoint(shuffled_scores_point_id, shuffled_scores_point_score);
                groupMemoryBarrier();
            }
        }
    }
}

#endif
