#version 450
#pragma use_vulkan_memory_model

#include "extensions.comp"

#include "common.comp"
layout(local_size_x = WORKGROUP_SIZE, local_size_y = 1, local_size_z = 1) in;

#define VECTOR_STORAGE_LAYOUT_SET 1
#include "vector_storage.comp"

#define LINKS_LAYOUT_SET 2
#include "links.comp"

#define VISITED_FLAGS_LAYOUT_SET 3
#include "visited_flags.comp"

#include "search_context.comp"

layout(set = 0, binding = 0) buffer Requests {
    ScoredPoint data[];
} requests;

layout(set = 0, binding = 1) buffer NewEntries {
    coherent uint data[];
} new_entries;

layout(set = 0, binding = 2) buffer Patches {
    coherent uint data[];
} patches;

void main() {
    search_context_init();
    uint group_index = gl_WorkGroupID.x;
    ScoredPoint request = requests.data[group_index * (EF + 1)];
    POINT_ID request_id = request.id;
    uint search_count = uint(request.score);
    nearest_count = search_count;

    for (uint i = gl_LocalInvocationID.x; i < search_count; i += WORKGROUP_SIZE) {
        shared_buffer[NEAREST_HEAP_OFFSET + i] = requests.data[group_index * (EF + 1) + i + 1];
    }

    memoryBarrierShared();
    barrier();

    nearest_count = bheap_into_array(NEAREST_HEAP_OFFSET, nearest_count);

    memoryBarrierShared();
    barrier();

    if (gl_LocalInvocationID.x == 0) {
        if (search_count > 0) {
            new_entries.data[group_index] = shared_buffer[NEAREST_HEAP_OFFSET].id;
        } else {
            new_entries.data[group_index] = UINT_MAX;
        }
    }

    uint count = run_heuristic();

    memoryBarrierShared();
    barrier();

    // update request_id links
    uint patches_offset = group_index * (M0 + 2) * (M0 + 1);
    if (gl_LocalInvocationID.x == 0) {
        patches.data[patches_offset] = request_id;
        patches.data[patches_offset + 1] = count;
    }
    for (uint i = gl_LocalInvocationID.x; i < count; i += WORKGROUP_SIZE) {
        patches.data[patches_offset + 2 + i] = shared_buffer[NEAREST_HEAP_OFFSET + i].id;
        shared_buffer[CANDIDATES_HEAP_OFFSET + i] = shared_buffer[NEAREST_HEAP_OFFSET + i];
    }

    memoryBarrier();
    barrier();

    for (uint i = 0; i < count; i++) {
        uint insert_offset = patches_offset + (i + 1) * (M0 + 2);
        uint other_id = shared_buffer[CANDIDATES_HEAP_OFFSET + i].id;
        uint other_links_count = get_links_count(other_id);

        if (other_links_count < LEVEL_M) {
            if (gl_LocalInvocationID.x == 0) {
                patches.data[insert_offset] = other_id;
                patches.data[insert_offset + 1] = other_links_count + 1;
                patches.data[insert_offset + 2 + other_links_count] = request_id;
            }
            for (uint j = gl_LocalInvocationID.x; j < other_links_count; j += WORKGROUP_SIZE) {
                patches.data[insert_offset + 2 + j] = GET_LINK(other_id, j);
            }
        } else {
            set_target(other_id);
            nearest_count = 0;
            for (uint j = 0; j < other_links_count; j++) {
                POINT_ID link = GET_LINK(other_id, j);
                shared_buffer[NEAREST_HEAP_OFFSET + nearest_count] = ScoredPoint(
                    link,
                    similarity(link)
                );
                nearest_count++;
            }
            shared_buffer[NEAREST_HEAP_OFFSET + nearest_count] = ScoredPoint(
                request_id,
                similarity(request_id)
            );
            nearest_count++;

            MEMORY_BARRIER_SHARED;
            sort(NEAREST_HEAP_OFFSET, nearest_count);

            MEMORY_BARRIER_SHARED;
            uint other_new_links_count = run_heuristic();

            MEMORY_BARRIER_SHARED;
            BARRIER;

            if (gl_LocalInvocationID.x == 0) {
                patches.data[insert_offset] = other_id;
                patches.data[insert_offset + 1] = other_new_links_count;
            }
            for (uint j = gl_LocalInvocationID.x; j < other_new_links_count; j += WORKGROUP_SIZE) {
                patches.data[insert_offset + 2 + j] = shared_buffer[NEAREST_HEAP_OFFSET + j].id;
            }
        }

        MEMORY_BARRIER;
        BARRIER;
    }
}
