struct Request {
    uint id;
    uint entry;
};

layout(set = 0, binding = 0) buffer Requests {
    Request data[];
} requests;

layout(set = 0, binding = 1) buffer NewEntries {
    uint data[];
} new_entries;

layout(set = 0, binding = 2) buffer Atomics {
    uint data[];
} atomics;

void main() {
    search_context_init();
    Request request = requests.data[gl_GlobalInvocationID.y];

    set_vector_storage_target(request.id);
    float entry_score = similarity(request.entry);
    uint search_count = search(request.id, ScoredPoint(request.entry, entry_score));
    if (search_count == UINT_MAX) {
        // error while searching. propably candidates heap overflow
        return;
    }

    if (gl_GlobalInvocationID.x == 0) {
        if (search_count > 0) {
            new_entries.data[gl_GlobalInvocationID.y] = get_nearest(0).id;
        } else {
            new_entries.data[gl_GlobalInvocationID.y] = request.entry;
        }
    }

    uint count = run_heuristic();

    // sync all threads to make sure that we don't do search while updating links
    barrier();

    // update request.id links
    for (uint i = gl_GlobalInvocationID.x; i < count; i += WORKING_GROUP_SIZE) {
        GET_LINK(request.id, i) = get_nearest(i).id;
    }
    if (gl_GlobalInvocationID.x == 0) {
        LINKS_SET_SIZE(request.id, count);
    }
    barrier();

    uint generation = VISITED_GENERATION;

    for (uint i = 0; i < count; i++) {
        uint other_id = GET_LINK(request.id, i);

        uint other_links_count = LINKS_COUNT(other_id);
        if (other_links_count < LEVEL_M) {
            if (gl_GlobalInvocationID.x == 0) {
                GET_LINK(other_id, other_links_count) = request.id;
                LINKS_SET_SIZE(other_id, other_links_count + 1);
            }
        } else {
            set_vector_storage_target(other_id);
            nearest_count = 0;
            LINKS_FOREACH(other_id) {
                set_nearest(
                    nearest_count,
                    ScoredPoint(
                        LINKS_FOREACH_VALUE,
                        similarity(LINKS_FOREACH_VALUE))
                );
                nearest_count++;
            }
            set_nearest(
                nearest_count,
                ScoredPoint(
                    request.id,
                    similarity(request.id))
            );
            nearest_count++;

            sort_nearest();
            uint other_new_links_count = run_heuristic();
            barrier();

            for (uint j = gl_GlobalInvocationID.x; j < other_new_links_count; j += WORKING_GROUP_SIZE) {
                GET_LINK(other_id, j) = get_nearest(j).id;
            }
            if (gl_GlobalInvocationID.x == 0) {
                LINKS_SET_SIZE(other_id, other_new_links_count);
            }
        }
        barrier();
    }
}
