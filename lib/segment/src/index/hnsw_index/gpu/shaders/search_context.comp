#ifndef SEARCH_CONTEXT_HEADER
#define SEARCH_CONTEXT_HEADER

bool process_candidate(ScoredPoint scored_point) {
    bool not_presented = nearest_smaller.id != scored_point.id;
    bool was_added = push_nearest(scored_point);
    if (was_added && not_presented) {
        return push_candidate(scored_point);
    }
    return true;
}

bool process_candidate(POINT_ID point_id, POINT_ID candidate_id) {
    uint links_count = LINKS_COUNT(candidate_id);
    //uint thread_link = gl_GlobalInvocationID.x < links_count ? GET_LINK(candidate_id, gl_GlobalInvocationID.x) : UINT_MAX;
    //bool thread_is_visited = gl_GlobalInvocationID.x < links_count ? is_visited(thread_link) : true;
    //if (!thread_is_visited && gl_GlobalInvocationID.x < links_count) {
    //    mark_visited(thread_link);
    //}

    for (uint i = 0; i < links_count; i++) {
        //if (gl_GlobalInvocationID.x == i) {
        //    merge_buffer[0].id = thread_link;
        //    merge_buffer[0].score = thread_is_visited ? 1.0 : 0.0;
        //}
        //barrier();
        //uint link = merge_buffer[0].id;
        //bool is_visited = merge_buffer[0].score == 1.0;

        uint link = GET_LINK(candidate_id, i);
        bool visited = is_visited(link);

        if (!visited) {
            mark_visited(link);

            float score = similarity(link);
            ScoredPoint scored_point = ScoredPoint(link, score);
            bool success = process_candidate(scored_point);
            if (!success) {
                return false;
            }
        }
    }

    return true;
}

uint search(POINT_ID point_id, ScoredPoint entry) {
    if (gl_GlobalInvocationID.x == 0) {
        mark_visited(point_id);
        mark_visited(entry.id);
    }
    push_nearest(entry);
    push_candidate(entry);
    
    while (candidates_count > 0) {
        ScoredPoint candidate = pop_candidate();
        if (candidate.score < nearest_smaller.score) {
            continue;
        }
        process_candidate(point_id, candidate.id);
    }

    process_candidate(point_id, point_id);

    sort_nearest();
    return nearest_count;
}

ScoredPoint greedy_search(POINT_ID point_id, ScoredPoint entry) {
    bool changed = true;
    ScoredPoint result = entry;

    while (changed) {
        changed = false;

        uint current = result.id;
        uint links_count = LINKS_COUNT(current);
        uint thread_link = gl_GlobalInvocationID.x < links_count ? GET_LINK(current, gl_GlobalInvocationID.x) : UINT_MAX;
        for (uint i = 0; i < links_count; i++) {
            if (gl_GlobalInvocationID.x == i) {
                merge_buffer[0].id = thread_link;
            }
            barrier();
            uint link = merge_buffer[0].id;

            float score = similarity(link);
            if (score > result.score) {
                changed = true;
                result = ScoredPoint(link, score);
            }
        }
    }
    return result;
}

uint run_heuristic() {
    uint result_count = 0;

    for (uint i = 0; i < nearest_count; i++) {
        if (result_count >= LEVEL_M) {
            break;
        }

        ScoredPoint current_closest = get_nearest(i);
        set_vector_storage_target(current_closest.id);
        bool is_good = true;

        for (uint j = 0; j < result_count; j++) {
            ScoredPoint selected_point = get_nearest(j);
            float dist_to_already_selected = similarity(selected_point.id);
            if (dist_to_already_selected > current_closest.score) {
                is_good = false;
                break;
            }
        }

        if (is_good) {
            set_nearest(result_count, current_closest);
            result_count += 1;
        }
    }

    nearest_count = result_count;
    return result_count;
}

void search_context_init() {
    nearest_heap_init();
    candidates_heap_init();
}

#endif
