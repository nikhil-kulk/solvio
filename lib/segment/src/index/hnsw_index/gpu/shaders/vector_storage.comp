#ifndef VECTOR_STORAGE_HEADER
#define VECTOR_STORAGE_HEADER

#ifndef VECTOR_STORAGE_LAYOUT_SET
#error "VECTOR_STORAGE_LAYOUT_SET not defined"
#endif

#ifdef VECTOR_STORAGE_ELEMENT_FLOAT32

#define VECTOR_STORAGE_ELEMENT_TYPE vec4
#define VECTOR_STORAGE_SCORE_ELEMENT(a, b) dot(a, b)

#endif

#ifdef VECTOR_STORAGE_ELEMENT_FLOAT16

#extension GL_EXT_shader_explicit_arithmetic_types_float16 : enable
#define VECTOR_STORAGE_ELEMENT_TYPE f16vec4
#define VECTOR_STORAGE_SCORE_ELEMENT(a, b) dot(a, b)

#endif

#ifdef VECTOR_STORAGE_ELEMENT_UINT8

float dot_u8vec4(u8vec4 a, u8vec4 b) {
    uint sum = uint(a.x) * uint(b.x) + uint(a.y) * uint(b.y) + uint(a.z) * uint(b.z) + uint(a.w) * uint(b.w);
    return float(sum);
}

#define VECTOR_STORAGE_ELEMENT_TYPE u8vec4
#define VECTOR_STORAGE_SCORE_ELEMENT(a, b) dot_u8vec4(a, b)

#endif

#ifdef VECTOR_STORAGE_ELEMENT_BINARY

#define VECTOR_STORAGE_ELEMENT_TYPE uint
// TODO: find glsl function for XOR
#define VECTOR_STORAGE_SCORE_ELEMENT(i, j) float(bitCount((a | b) - (a & b)))

#endif

#ifndef VECTOR_STORAGE_ELEMENT_TYPE
#error "VECTOR_STORAGE_ELEMENT not defined"
#endif

#include "common.comp"

layout(set = VECTOR_STORAGE_LAYOUT_SET, binding = 0)
readonly uniform VectorStorageParams {
    uint dim;
    uint count;
    uint chunk_size;
} vector_storage_params;

#define COUNT vector_storage_params.count

#define DIM vector_storage_params.dim

#define STORAGES_COUNT 4

#define STORAGE(STORAGE_INDEX) CONCAT(vectors, STORAGE_INDEX)

#define VECTOR_STORAGE_DEFINE(STORAGE_INDEX) \
    layout(set = VECTOR_STORAGE_LAYOUT_SET, binding = 1 + STORAGE_INDEX) \
    readonly buffer CONCAT(Vectors, STORAGE_INDEX) { \
        VECTOR_STORAGE_ELEMENT_TYPE data[]; \
    } STORAGE(STORAGE_INDEX);

VECTOR_STORAGE_DEFINE(0)
VECTOR_STORAGE_DEFINE(1)
VECTOR_STORAGE_DEFINE(2)
VECTOR_STORAGE_DEFINE(3)

#define VECTOR_STORAGE_SCORE_SUBGROUP(STORAGE_INDEX_A, STORAGE_INDEX_B) \
    for (uint i = 0; i < d; i += SUBGROUP_SIZE, aIndex += SUBGROUP_SIZE, bIndex += SUBGROUP_SIZE) { \
        result += VECTOR_STORAGE_SCORE_ELEMENT( \
            STORAGE(STORAGE_INDEX_A).data[aIndex], \
            STORAGE(STORAGE_INDEX_B).data[bIndex] \
        ); \
    }

float similarity(uint a, uint b) {
    float result = 0.0;
    uint d = DIM / 4;
    uint aIndex = (a / STORAGES_COUNT) * d + SUBGROUP_INVOKATION_ID;
    uint bIndex = (b / STORAGES_COUNT) * d + SUBGROUP_INVOKATION_ID;
    uint storage_index_a = a % STORAGES_COUNT;
    uint storage_index_b = b % STORAGES_COUNT;

    switch (storage_index_a) {
    case 0:
        switch (storage_index_b) {
        case 0:
            VECTOR_STORAGE_SCORE_SUBGROUP(0, 0);
            break;
        case 1:
            VECTOR_STORAGE_SCORE_SUBGROUP(0, 1);
            break;
        case 2:
            VECTOR_STORAGE_SCORE_SUBGROUP(0, 2);
            break;
        case 3:
            VECTOR_STORAGE_SCORE_SUBGROUP(0, 3);
            break;
        }
        break;
    case 1:
        switch (storage_index_b) {
        case 0:
            VECTOR_STORAGE_SCORE_SUBGROUP(1, 0);
            break;
        case 1:
            VECTOR_STORAGE_SCORE_SUBGROUP(1, 1);
            break;
        case 2:
            VECTOR_STORAGE_SCORE_SUBGROUP(1, 2);
            break;
        case 3:
            VECTOR_STORAGE_SCORE_SUBGROUP(1, 3);
            break;
        }
        break;
    case 2:
        switch (storage_index_b) {
        case 0:
            VECTOR_STORAGE_SCORE_SUBGROUP(2, 0);
            break;
        case 1:
            VECTOR_STORAGE_SCORE_SUBGROUP(2, 1);
            break;
        case 2:
            VECTOR_STORAGE_SCORE_SUBGROUP(2, 2);
            break;
        case 3:
            VECTOR_STORAGE_SCORE_SUBGROUP(2, 3);
            break;
        }
        break;
    case 3:
        switch (storage_index_b) {
        case 0:
            VECTOR_STORAGE_SCORE_SUBGROUP(3, 0);
            break;
        case 1:
            VECTOR_STORAGE_SCORE_SUBGROUP(3, 1);
            break;
        case 2:
            VECTOR_STORAGE_SCORE_SUBGROUP(3, 2);
            break;
        case 3:
            VECTOR_STORAGE_SCORE_SUBGROUP(3, 3);
            break;
        }
        break;
    }

#ifdef VECTOR_STORAGE_ELEMENT_BINARY
    return subgroupAdd(result);
#else
    float xor_product = result;
    float zeros_count = float(d * 32) - xor_product;
    return zeros_count - xor_product;
#endif
}

#endif
