#ifndef VECTOR_STORAGE_HEADER
#define VECTOR_STORAGE_HEADER

#ifndef VECTOR_STORAGE_LAYOUT_SET
#error "VECTOR_STORAGE_LAYOUT_SET not defined"
#endif

#ifndef DIM
#error "DIM not defined"
#endif

#ifdef VECTOR_STORAGE_ELEMENT_FLOAT32

#define VECTOR_STORAGE_ELEMENT_TYPE vec4
#define VECTOR_STORAGE_SCORE_ELEMENT(a, b) dot(a, b)

#endif

#ifdef VECTOR_STORAGE_ELEMENT_FLOAT16

#extension GL_EXT_shader_explicit_arithmetic_types_float16 : enable
#define VECTOR_STORAGE_ELEMENT_TYPE f16vec4
#define VECTOR_STORAGE_SCORE_ELEMENT(a, b) dot(a, b)

#endif

#ifdef VECTOR_STORAGE_ELEMENT_UINT8

float dot_u8vec4(u8vec4 a, u8vec4 b) {
    uint sum = uint(a.x) * uint(b.x) + uint(a.y) * uint(b.y) + uint(a.z) * uint(b.z) + uint(a.w) * uint(b.w);
    return float(sum);
}

#define VECTOR_STORAGE_ELEMENT_TYPE u8vec4
#define VECTOR_STORAGE_SCORE_ELEMENT(a, b) dot_u8vec4(a, b)

#endif

#ifdef VECTOR_STORAGE_ELEMENT_BINARY

// uint = 4 * uint8_t, vec4 analogue for BQ
#define VECTOR_STORAGE_ELEMENT_TYPE uint
#define VECTOR_STORAGE_SCORE_ELEMENT(a, b) float(bitCount(a ^ b))

#endif

#ifndef VECTOR_STORAGE_ELEMENT_TYPE
#error "VECTOR_STORAGE_ELEMENT not defined"
#endif

#define STORAGES_COUNT 4

#define STORAGE(STORAGE_INDEX) CONCAT(vectors, STORAGE_INDEX)

#define VECTOR_STORAGE_DEFINE(STORAGE_INDEX) \
    layout(set = VECTOR_STORAGE_LAYOUT_SET, binding = STORAGE_INDEX) \
    readonly buffer CONCAT(Vectors, STORAGE_INDEX) { \
        VECTOR_STORAGE_ELEMENT_TYPE data[]; \
    } STORAGE(STORAGE_INDEX);

VECTOR_STORAGE_DEFINE(0)
VECTOR_STORAGE_DEFINE(1)
VECTOR_STORAGE_DEFINE(2)
VECTOR_STORAGE_DEFINE(3)

#define VECTOR_STORAGE_SCORE_SUBGROUP(STORAGE_INDEX_A) \
    for (uint i = 0; i < (d / SUBGROUP_SIZE); i += 1, aIndex += SUBGROUP_SIZE) { \
        result += VECTOR_STORAGE_SCORE_ELEMENT( \
            STORAGE(STORAGE_INDEX_A).data[aIndex], \
            vector_cache[i] \
        ); \
    }

#define VECTOR_STORAGE_LOAD_CACHE(STORAGE_INDEX_A) \
    for (uint i = 0; i < (d / SUBGROUP_SIZE); i += 1, aIndex += SUBGROUP_SIZE) { \
        vector_cache[i] = STORAGE(STORAGE_INDEX_A).data[aIndex]; \
    }

VECTOR_STORAGE_ELEMENT_TYPE vector_cache[DIM / (4 * SUBGROUP_SIZE)];

void set_vector_storage_target(uint a) {
    uint d = DIM / 4;
    uint aIndex = (a / STORAGES_COUNT) * d + SUBGROUP_INVOCATION_ID;
    uint storage_index_a = a % STORAGES_COUNT;

    switch (storage_index_a) {
    case 0:
        VECTOR_STORAGE_LOAD_CACHE(0);
        break;
    case 1:
        VECTOR_STORAGE_LOAD_CACHE(1);
        break;
    case 2:
        VECTOR_STORAGE_LOAD_CACHE(2);
        break;
    case 3:
        VECTOR_STORAGE_LOAD_CACHE(3);
        break;
    }
}

float similarity(uint a) {
    float result = 0.0;
    uint d = DIM / 4;
    uint aIndex = (a / STORAGES_COUNT) * d + SUBGROUP_INVOCATION_ID;
    uint storage_index_a = a % STORAGES_COUNT;

    switch (storage_index_a) {
    case 0:
        VECTOR_STORAGE_SCORE_SUBGROUP(0);
        break;
    case 1:
        VECTOR_STORAGE_SCORE_SUBGROUP(1);
        break;
    case 2:
        VECTOR_STORAGE_SCORE_SUBGROUP(2);
        break;
    case 3:
        VECTOR_STORAGE_SCORE_SUBGROUP(3);
        break;
    }

#ifdef VECTOR_STORAGE_ELEMENT_BINARY
    float xor_product = subgroupAdd(result);
    float zeros_count = float(d * 32) - xor_product;
    return zeros_count - xor_product;
#else
    return subgroupAdd(result);
#endif
}

#endif
